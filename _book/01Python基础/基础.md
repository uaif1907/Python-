#### 1. 列出5个python标准库
os datetime sys re math

#### 2. python内建数据类型有哪些
整型--int 布尔型--bool 字符串--str 列表--list 元组--tuple 字典--dict
#### 3. 简述面向对象中__new__和__init__区别
```
__init__是初始化方法，创建对象后，就立刻被默认调用了，可接收参数
__new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别
__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类（通过super(当前类名, cls)）__new__出来的实例，或者直接是object的__new__出来的实例
__init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值
如果__new__创建的是当前类的实例，会自动调用__init__函数，通过return语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。 
```
#### 4. 什么是上下文管理器
```
上下文管理器就是一个包装任意代码块的对象，上下文管理器保证进入上下文管理器时，每次代码执行的一致性，当退出上下文管理器时，相关的资源会被正确的回收。使用上下文管理器的好处是，一定能够保证退出步骤的执行， 通过 with 语句在编写代码时，会使代码变得更加简洁，不用再去关闭文件.
上下文管理器有两个方法：__enter__、__exit__作用：用于资源的获取和释放。
__enter__和__exit__方法的对象优点：提高代码的复用率；提高代码的优雅度；提高代码的可读性
Python 还提供了一个 contextmanager 装饰器，更进一步简化上下管理器的实现方式。
上下文管理器可以在__exit__ 进行捕获并由你自己决定如何处理，是抛出呢还是在这里就解决了
在 写__exit__ 函数时，需要注意的事，它必须要有这三个参数：
exc_type：异常类型
exc_val：异常值
exc_tb：异常的错误栈信息
当主逻辑代码没有报异常时，这三个参数将都为None。
```
#### 5. 迭代器与生成器
```
迭代器是一个更抽象的概念，任何对如果它类有 next 方法和 iter 方法返回自己本身 。对于 strings、 list、 dict、 tuple 等这类容器对象，使用 for 循环遍历是很方便的。在后台 for 语句 对容器象调用 iter()函数，iter()是 python 的内置函数。iter() 会返回一个定义 next()方法的迭代器对象，它在容器中逐个访问容 器内元素， next()也是 python 的内置函数。在没有后续元素时， next()会 抛出一个 StopIter 异常
生成器（ Generator）是创建迭代器的简单而强大工具。 它们写起来就像是正规的函数，只在需要返回据时候使用 yield 语 句。每次 next()被调用，生成器会返回它脱离的位置，记忆语句最 后一次执行和所有数据。 区别：生成器能做到迭代的所有事 ,而且因为自动创建了 iter()和 next()方法 ,生成器显得特别简洁 ,而且生成器也是 高效的 ，使用生成器表 达式取代列解析可以同时节省 内存。除了 创建和保程序状态的自动方法,当发生器终结时 ,还会自动抛出 StopIteration 异常
```
#### 6. IOError、AttributeError、ImportError、IndentationError、IndexError、KeyError、SyntaxError、NameError分别代表什么异常
```
IOError：输入输出异常
AttributeError：试图访问一个对象没有的属性
ImportError：无法引入模块或包，基本是路径问题
IndentationError：语法错误，代码没有正确的对齐
IndexError：下标索引超出序列边界
KeyError:试图访问你字典里不存在的键
SyntaxError:Python代码逻辑语法出错，不能执行
NameError:使用一个还未赋予对象的变量
```
#### 7. python中copy和deepcopy区别
```
1、复制不可变数据类型，不管copy还是deepcopy,都是同一个地址当浅复制的值是不可变对象（数值，字符串，元组）时和=“赋值”的情况一样，对象的id值与浅复制原来的值相同。
2、复制的值是可变对象（列表和字典）
浅拷贝copy有两种情况：
第一种情况：复制的 对象中无 复杂 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。
第二种情况：复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表）， 改变原来的值 中的复杂子对象的值  ，会影响浅复制的值。
深拷贝deepcopy：完全复制独立，包括内层列表和字典
```
#### 8. 列出几种魔法方法并简要介绍用途
```
__init__:对象初始化方法
 
__new__:创建对象时候执行的方法，单列模式会用到
 
__str__:当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据
 
__del__:删除对象执行的方法
```
#### 9. Python垃圾回收机制
```
主要是以对象引用计数为主标记清除和分代技术为辅的那么一种方式
Python在内存中存储了每个对象的引用计数（reference count）。如果计数值变为0，那么相应的对象就会消失。分配给该对象的内存就会释放出来用作他用。
偶尔也会出现引用循环。垃圾回收器会定时寻找这个循环，并将其回收。
Python中还使用了某些启示算法来加速回收。
```
#### 10. Python如何进行内存管理
```
　　Python引用了一个内存池(memory pool)机制，即Pymalloc机制(malloc:n.分配内存)，用于管理对小块内存的申请和释放
内存池（memory pool）的概念：
　　当 创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是预先在内存中申请一定数量的，大小相等 的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。
内存池的实现方式有很多，性能和适用范围也不一样。
python中的内存管理机制——Pymalloc：
　　python中的内存管理机制都有两套实现，一套是针对小对象，就是大小小于256bits时,pymalloc会在内存池中申请内存空间；当大于256bits，则会直接执行new/malloc的行为来申请内存空间。
　　关于释放内存方面，当一个对象的引用计数变为0时，python就会调用它的析构函数。在析构时，也采用了内存池机制，从内存池来的内存会被归还到内存池中，以避免频繁地释放动作。
```
#### 11. 将"hello world"转换为首字母大写"Hello World"
#### 12. 如何检测字符串中只含有数字?
#### 13. 将字符串"ilovechina"进行反转
#### 14. 如何打乱一个列表的元素？
#### 15. 如何判断一个对象是函数还是方法？
#### 16. hasattr() getattr() setattr()的用法
#### 17.pyhton可变数据类型不可变数据类型
```
不可变数据类型： 当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种数据类型，就称不可变数据类型。
可变数据类型 ：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数据类型，就称可变数据类型。
数据类型|可变/不可变
--|--
整型|不可变
字符串|不可变
元组|不可变
列表|可变
集合|可变
字典|可变
```
#### 18.装饰器
```
装饰器是一个很著名的设计模式，经常被用于有切面需求的场景， 较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类 问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数 功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是 为已经存在的对象添加额外的功能
装饰器(decorator)里引入通用功能处理：
引入日志
函数执行时间统计
执行函数前预备处理
权限校验等场景
缓存
```

#### 19. python中的断言
```
关键字：assert
　　　　Assert后面跟合法的表达式，当表达式为True是，不做任何操作，为False时回抛出异常，assert可以快速定位代码中的错误
```
#### 20. 实现一个斐波那契数列的生成器
```
def fib(n):
　　　    a, b = 0, 1
　　　    for _ in range(n):
　　        a, b = b, a + b
　　　        yield a
　　　　def main():
　　　　  for val in fib(20):
　　　　       print(val)
　　　　if __name__ == '__main__':
　　　　    main()
```
#### 21.三元运算规则
#### 22.进程，线程，协程
```
进程是系统进行资源分配和调度的一个独立单位。每个进程 都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进 程比较重量，占据独立的内存，所以上下文进程间的切换开销比较大，但相对比较稳定安全

线程是 CPU 调度和分派的基本单位它 是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统 资源，线程间通信主要通过共享内存，上下文切换很快，资源开 销较少，但相比进程不够稳定容易丢失数据。

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程调度切换时，将寄存器上下 文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上 下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访 问全局变量，所以上下文的切换非常快。
```
#### 23.迭代器和生成器的区别
```
生成器能做到迭代的所有事 ,而且因为自动创建了 iter()和 next()方法 ,生成器显得特别简洁 ,而且生成器也是 高效的 ，使用生成器表 达式取代列解析可以同时节省 内存。除了 创建和保程序状态的自动方法,当发生器终结时 ,还会自动抛出 StopIteration 异常
```
#### 24.父子间如何传递数据
```
父组件通过 prop 给子组件下发数据 子向父就是vue自定义事件 像监听，触发事件等。
```
