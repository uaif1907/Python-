#### 1.谈下python的GIL
GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。
多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大
#### 2. 简述多线程、多进程
```
进程：
1、操作系统进行资源分配和调度的基本单位，多个进程之间相互独立
2、稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制
线程：
1、CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源
2、如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃
应用：
IO密集的用多线程，在用户输入，sleep 时候，可以切换到其他线程执行，减少等待的时间
CPU密集的用多进程，因为假如IO操作少，用多线程的话，因为线程共享一个全局解释器锁，当前运行的线程会霸占GIL，其他线程没有GIL，就不能充分利用多核CPU的优势
```
#### 3. 举例说明 conccurent.future 的中线程池的用法
#### 4. 说一说多线程，多进程和协程的区别。
#### 5. 进程之间如何通信
#### 6. IO 多路复用的作用？
#### 7. select、poll、epoll 模型的区别？
#### 8. 什么是并发和并行？
#### 9. 一个线程 1 让线程 2 去调用一个函数怎么实现？
#### 10. 解释什么是异步非阻塞？
#### 11. threading.local 的作用？
#### 12.为什么需要进程池Pool?
当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态成生多个进程，十几个还好，但如果是上百个，上千个目标，手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。 
Pool可以提供指定数量的进程供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来它。
#### 13. 线程注意点:
+ 线程之间执行是无序
+ 主线程会等待所有的子线程执行完成以后程序再退出。要主线程退出了程序，子线程还在执行代码，执行完毕后才能退出程序
+ 表示守护主线程,主线程退出子线程直接销毁不再执行对应的代码。daemon=True 表示守护主线程，主线程退出子线程直接销毁不再执行对应的代码
#### 14.自定义线程的类方法，属性。
###### 通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承threading.Thread就可以了，然后重写run方法，__init__方法。

###### 如果子类提供了构造方法（自定义属性），默认不会调用父类的构造方法，需要自己手动调用

        建议：自己提供了构造方法的话需要使用super调用父类的构造方法

        super(父类名, self).__init__()

###### 创建自定义线程对象, 提示: 不要这里使用target执行某个任务，因为执行任务同一在run方法里面执行的

custom_thread(类对象） = CustomThread（类名）("show_info1", "show_info2")

　　　　重写run类方法，不要直接调用run方法，因为start方法内部已经调用run方法，启动线程统一start方法
#### 15.全局变量
在一个进程内所有的线程共享全局变量，共享数据。
+ 多线程对全局变量进行操作时，会有可能出现资源竞争，导致数据错误。

+ 可变类型（全局变量）：内存地址不变，不要加上global全局声明。

+ 不可变类型（全局变量）：内存地址发生变化，需要公用全局变量，就要global声明。
#### 16.互斥锁
能保证同一时刻只有一个线程去执行代码，具体那个线程抢到锁我们决定不了，但是加上互斥锁多任务瞬间变成单任务。性能下降。    
###### 执行流程：（1）在外部创建互斥锁　lock = threading.Lock()
（2）在线程执行代码方法中上锁：lock.acquire()
（3）有上锁就要释放锁，不释放就会变成死锁，造成代码堵塞：lock.release()
线程执行是无序的，谁先抢到锁，谁先执行。
#### 17.获取进程PID
```
os.getpid()
　　功能 ： 获取当前进程的进程号
　　返回值 ： 返回进程号

os.getppid()
　　功能 ： 获取当前进程父进程的PID号
　　返回值 ： 返回进程号

　　进程退出

os._exit(status)
　　功能 ： 进程退出
　　参数 ： 进程的退出状态

sys.exit([status])
　　功能 ： 进程退出
　　参数 ： 数字表示退出状态，不写默认为0
　　字符串，表示退出时打印的内容

　　* sys.exit 可以通过捕获 SystemExit异常阻止退出
```
#### 18.多任务编程
    ###### 意义:充分利用计算机的资源提高程序的运行效率

    ###### 定义:通过应用程序,利用计算机的多个核心达到同时执行多个任务的目的,以此    提高计算机运行效率
    ###### 实施方案:多进程    多线程
    ###### 并行:多个计算机核心在同时处理多个任务,这时多个任务间是并行关系

    ###### 并发:同时处理多个任务,内核在多个任务间不断的切换达到好像都在处理运行的效果,但实际一个时间点内核只能处理其中一个任务.
#### 19.Process类常⽤⽅法：
+ is_alive()： 判断进程实例是否还在执⾏；
+ join([timeout])： 是否等待进程实例执⾏结束，或等待多少秒；
+ start()： 启动进程实例（创建⼦进程）；
+ run()： 如果没有给定target参数，对这个对象调⽤start()⽅法时，就将执 ⾏对象中的run()⽅法；
+ terminate()： 不管任务是否完成，⽴即终⽌；
#### 19.fork函数的作用：
###### 1.执行到os.fork()时，操作系统会创建一个新的进程复制父进程的所有信息到子进程中。
###### 2.普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次。
###### 3.父进程和子进程都会从fork()函数中得到一个返回值，子进程返回的是0，而父进程中返回子进程的id号。
#### 消息队列
可以使⽤multiprocessing模块的Queue实现多进程之间的数据传递，Queue 本身是⼀个消息列队程序。
```
Queue.qsize()： 返回当前队列包含的消息数量；
Queue.empty()： 如果队列为空，返回True，反之False ；
Queue.full()： 如果队列满了，返回True,反之False；
Queue.get([block[, timeout]])：
获取队列中的⼀条消息，然后将其从列队中移除，block默认值为True；
Queue.get_nowait()：
相当Queue.get(False)；
Queue.put(item,[block[, timeout]])：
将item消息写⼊队列，block默认值 为True；
Queue.put_nowait(item)：
相当Queue.put(item, False)
```
#### 20.如何实现线程锁？
（1）、实例化一个锁对象  lock = new threading.Lock()     
（2）、造作白能量之前进行加锁  lock.acquire()   
（3）、操作变量之后进行解锁  lock.release()   
#### 21.死锁
在线程间共享多个资源的时候，如果两个线程分别占有⼀部分资源并且同时 等待对⽅的资源，就会造成死锁。 
#### 22.多线程有几种实现方法，都是什么？
分别是实例化对象方法，以及创建子类方法。
#### 23.协程中的join是用来做什么用的？它是如何发挥作用的？
#### 24.常见的协程模块有哪些？




