#### 1. TCP 和 UDP 的区别？
```
1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP对系统资源要求较多，UDP对系统资源要求较少。
```
#### 2. 简要介绍三次握手和四次挥手
```
所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发

第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
第三次握手:Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发

第一次挥手：
Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
第二次挥手：
Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
第三次挥手：
Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
第四次挥手：
Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。
```
#### 3. 什么是粘包？socket 中造成粘包的原因是什么？哪些情况会发生粘包现象？
```
粘包:
指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。

socket 中造成粘包的原因:
发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。

哪些情况会发生粘包现象:
接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。分包是指在出现粘包的时候我们的接收方要进行分包处理。

```
#### 4.并发与并行
```
并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。简言之，是指系统具有处理多个任务的能力。
并行：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。简言之，是指系统具有同时处理多个任务的能力。
```
#### 5.同步与异步
```
同步：当进程执行IO(等待外部数据）的时候，-----等。同步（例如打电话的时候必须等）
就是在发出一个功能调用时，在没有得到结果之前，该 调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例 如 sin, isdigit 等）。但是一般而言，我们在说同步、异步的时候， 特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的 例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处 理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把 消息处理函数所返回的 LRESULT 值返回给调用者。
异步：当进程执行IO(等待外部数据）的时候，-----不等，去执行其他任务，一直等到数据接收成功，再回来处理。异步（例如发短信）当一个异步过程调用发出后，调用者不能 立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知 和回调来通知调用者。
```
#### 6.阻塞与非阻塞
```
阻塞调用是指调用结果返回之前，当前线程会被挂起（如遇到io操作）。调用线程只有在得到结果之后才会返回。函数只有在得到结果之后才会将阻塞的线程激活。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。
非阻塞和阻塞的概念相对应，非阻塞调用指在不能立刻得到结果之前也会立刻返回，同时该函数不会阻塞当前线程。
```
#### 7.常见状态码有那些
```
200 - 请求成功
301 - 资源（网页等）被永久转移到其它URL
404 - 请求的资源（网页等）不存在
500 - 内部服务器错误
1** 信息，服务器收到请求，需要请求者继续执行操作
2** 成功，操作被成功接收并处理
3** 重定向，需要进一步的操作以完成请求
4** 客户端错误，请求包含语法错误或无法完成请求
5** 服务器错误，服务器在处理请求的过程中发生了错误
```
#### 8.线程、进程、协程
```
进程是具有一定独立功能的程序关于某个数据集合上的一次运 行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程 都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进 程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、 寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全
线程是进程的一个实体,是 CPU 调度和分派的基本单位,它 是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统 资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存 器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的 全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开 销较少，但相比进程不够稳定容易丢失数据。
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下 文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上 下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访 问全局变量，所以上下文的切换非常快。
```
#### 9.简述 OSI 七层协议
```
1、物理层
为数据链路层提供物理连接，实现比特流的透明传输，所传输数据的单位是比特，该层定义了通信设备与传输线接口硬件的电气、机械以及功能和过程的特性。
2、数据链路层
在通信的实体之间建立数据链路连接，传送以帧为单位的数据，通过检查发生在连接通信系统间传送路上的比特错误并进行恢复，确保比特序列组成为数据流准确无误地传送给对方的系统。数据链路层在相邻的节点之间实现透明的高可靠性传输。
3、网络层
解决多节点传送时的路由选择、拥挤控制及网络互连等，控制分组传送系统的操作，它的特性对高层是透明的，同时，根据传输层的要求选择服务质量，并向传输层报告未恢复的差错。
4、传输层
为两个端系统（源站和目标站）的会话层之间建立一条传输连接，可靠、透明地传送报文，执行端一端差错控制、顺序和流量控制、管理多路复用等。本层提供建立、维护和拆除传送连接的功能，并保证网络连接的质量。它向高层屏蔽了下层数据通信的细节，因而是OSI网络参考模型中最需要的一层。
5、会话层
不参与具体的数据传输，但对数据传输的同步进行管理。它主要负责提供两个进程之间建立、维护和结束会话连接功能，同时要对进程中必要的信息传送方式、进程间的同步以及重新同步进行管理。
6、表示层
解决在两个通信系统中交换信息时不同数据格式的编码之间的转换，语法选择，数据加密与解密及文本压缩等。
7、应用层
负责向用户提供各种网络应用服务，如文件传输、电子邮件、远程访问等。把进程中于对方进程通信的部分放入应用实体中，同时，对各种业务内容的通信功能进行管理。
```
#### 10.什么是C/S和B/S架构？
```
C/S架构软件:
（即客户机/服务器模式）分为客户机和服务器两层：第一层是在客户机系统上结合了表示与业务逻辑，第二层是通过网络结合了数据库服务器。简单的说就是第一层是用户表示层，第二层是数据库层。客户端和服务器直接相连，这两个组成部分都承担着重要的角色。

B/S型模式:
即浏览器/服务器结构。它是C/S架构的一种改进，可以说属于三层C/S架构。主要是利用了不断成熟的WWW浏览器技术，用通用浏览器就实现了原来需要复杂专用软件才能实现的强大功能，并节约了开发成本，是一种全新的软件系统构造技术。
```
#### 11.什么是arp协议？
```
地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。
```
#### 12.什么是局域网和广域网？
```
局域网和广域网是按规模大小而划分的两种计算机网络。范围在几千米以内的计算机网络统称为局域网；而连接的范围超过10千米的，则称为广域网，因特网（Intenet）就是目前最大的广域网。
```
#### 13.为何基于tcp协议的通信比基于udp协议的通信更可靠？
```
TCP的可靠保证,是它的三次握手双向机制,这一机制保证校验了数据,保证了他的可靠性。而UDP就没有了,udp信息发出后,不验证是否到达对方,所以不可靠。
```
#### 14.什么是socket？简述基于tcp协议的套接字通信流程。
```
Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。
```
#### 15.IO多路复用的作用？
```
I/O多路复用是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
```
#### 16.什么是防火墙以及作用？
```
简单的来说，防火墙就是一种，避免你的电脑被黑客入侵的一种防护工具，一种确保网络安全的方法！
允许网络管理员定义一个中心点来防止非法用户进入内部网络。2．可以很方便地监视网络的安全性，并报警。3．可以作为部署NAT（Network Address Translation，网络地址变换）的地点，利用NAT技术，将有限的IP地址动态或静态地与内部的IP地址对应起来，用来缓解地址空间短缺的问题等
```
#### 17.select、poll、epoll 模型的区别？
```
（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。
（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要 一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列）。这也能节省不少的开销。
```
#### 18.简述 进程、线程、协程的区别 以及应用场景？
```
进程拥有自己的堆和栈，既不共享堆也不共享栈 进程由操作系统调度
线程拥有自己的堆和共享的栈 共享栈 但不共享堆 线程也是由操作系统调度
协程和线程一样有自己的堆和共享的栈 共享栈但不共享堆 协程由开发人员在适当情况调用
```
#### 18.简述什么是GIL锁？
```
GIL:全局解释器锁。当我们用多线程的时候,每一个进程中只有一个GIL锁,那么这多个线程中谁拿到GIL锁，谁即可以用cpu(ps:多个进程有多个Gil锁，但每个进程中只有一个GIL)
```
#### 19.Python中如何使用线程池和进程池？
```
进程池：使用multiprocessing.Pool
线程池：使用ThreadPool模块
```
#### 20.threading.local的作用？
```
threadLocal解决了参数在一个线程中各个函数之间相互传递的问题
一个threadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本 互不干扰
```
#### 21.进程锁和线程锁的作用？
```
当多进程或多线程是不用进程访问相同一个变量是会造成同一时间执行相同的事 而得不到正确的结果 所以需要用锁锁上这个全局变量，当某一个进程或线程访问时其他进程或线程均无法访问
```
#### 22.解释什么是异步非阻塞？
```
异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送，所以在发送的信息中就要有提示接收方开始接收的信息，如开始位，同时在结束时有停止位。
非阻塞模式是指利用socket事件的消息机制，Server端与Client端之间的通信处于异步状态。
```
#### 23.路由器和交换机的区别？
```
路由器是将信息通过ip转发 交换机是将数据传给下一个
```
#### 24.什么是域名解析？
```
域名解析是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务
```
#### 25.如何修改本地hosts文件？
```
记事本打开C:\Windows\System32\drivers\etc下的hosts文件进行修改
```
#### 26.生产者消费者模型应用场景及优势？
```
应用于一个生产数据一个处理数据的场景
优势生产者和消费者之间不直接进行通信 而是通过一个队列相当于一个缓冲区，平衡了生产者和消费者的处理能力
```
#### 27.什么是cdn？
```
尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
```
#### 28.Nginx是什么及作用？
```
我们可以了解到Nginx是一个http服务器。同效果的http服务器还有Apache、tomcat等
作用：
1、 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。
2、 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。基于端口的，不同的端口基于域名的，不同域名
3、 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。
```
#### 29.什么是负载均衡？
```
负载均衡是高可用网络基础架构的的一个关键组成部分，有了负载均衡，我们通常可以将我们的应用服务器部署多台，然后通过负载均衡将用户的请求分发到不同的服务器用来提高网站、应用、数据库或其他服务的性能以及可靠性。
```
#### 30.简述 asynio模块的作用和应用场景。
```
asyncio是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。
asyncio的编程模型就是一个消息循环。我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。
```
#### 31.简述 gevent模块的作用和应用场景。
```
当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。
由于切换是在IO操作时自动完成，所以gevent需要修改Python自带的一些标准库，这一过程在启动时通过monkey patch完成
```
#### 32.twisted框架的使用和应用？
```
Twisted是用Python实现的基于事件驱动的网络引擎框架，Twisted支持许多常见的传输及应用层协议，包括TCP、UDP、SSL/TLS、HTTP、IMAP、SSH、IRC以及FTP。就像Python一样，Twisted也具有“内置电池”（batteries-included）的特点。Twisted对于其支持的所有协议都带有客户端和服务器实现，同时附带有基于命令行的工具，使得配置和部署产品级的Twisted应用变得非常方便。
```